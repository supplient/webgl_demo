凹凸纹理中存的是高度数值，法线纹理里面存的才是法线数值。


注意存储纹理时gl内部会使用内存对齐，可以使用pixelStorei来修改字节对齐的数值。详见：
* https://stackoverflow.com/questions/11042027/glpixelstoreigl-unpack-alignment-1-disadvantages
* https://www.khronos.org/opengl/wiki/Pixel_Transfer#Pixel_layout
* https://blog.csdn.net/csxiaoshui/article/details/53032442
因此而可能有的问题就是由凹凸纹理计算法线纹理时可能会因为修改了纹理大小而导致不再对齐，而报错：
* https://stackoverflow.com/questions/42789896/webgl-error-arraybuffer-not-big-enough-for-request-in-case-of-gl-luminance



# gl_FragColor输出到纹理的机理
gl_FragColor接收一个vec4，其中四项分别对应RGBA，取值范围为[0.0, 1.0]。

假设输入vec4 color=(r, g, b, a)，则输出到纹理的时候是这样的：
1. 先让color乘一个255，得到一组在[0.0, 255.0]之间的值
2. 再四舍五入其中每一个值，得到一组在[0, 255]之间的整数值
3. 最后将这组值作为该像素的颜色值输出。纹理中存储的也是这组整数值。

例如vec4 color=(1.0/509.0, 1.0/510.0, 2.0/255.0, 1.0)，则
1. 先乘255，得到(0.50098, 0.5, 2.0, 255)
2. 再四舍五入（不过这里0.5不知道为啥也是被舍去，测试可知509.5也会被舍去），得到(1, 0, 2, 255)
3. 最后输出这组值，屏幕上显示的就是这组整数值，如果使用FBO的话，那么纹理中存储的也就是这组值

# 关于浮点数打包进gl_FragColor
假设浮点数为z=0.b1b2b3b4...（二进制表示），那么我们将它打包成向量
v=(0.b1b2...b8, 0.b9b10...b16, 0.b17b18...b24, b25b26...b32)，此时该向量的每一维的精度为1/256

注意到我们上面提到过gl_FragColor的机理，当我们将v传输给gl_FragColor也遵循上述机理，所以也是先乘个255，再四舍五入。

这里就存在一个问题，我们打包的时候的精度是1/256，所以可表示的数有257个数：0, 1/256, 2/256, ..., 255/256, 1。而在乘了255再四舍五入的话就会只能表示256个数了：0,1,2,3,4, ..., 254,255。也就是这样的映射会出现误差。

所以这里更合适的做法是让每一维的精度为1/255，这样每一维可表示的数就有256个：0, 1/255, 2/255, ..., 254/255, 1。可以完美地一一映射过去。
